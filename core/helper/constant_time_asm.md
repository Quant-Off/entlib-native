# 아키텍처별 인라인 어셈블리 기반 상수-시간 프리미티브(inline asm-based constant-time primitive) 모듈

이 문서는 `entlib-native`의 하위 모듈인 [아키텍처별 인라인 어셈블리 기반 상수-시간 프리미티브 모듈](src/constant_time_asm.rs)의 기술적 역할과 구현 세부 사항에 대해 설명합니다.

## 개요

`constant_time_asm.rs` 모듈은 컴파일러의 예상치 못한 최적화로 인해 상수-시간(constant-time) 특성이 훼손되는 것을 원천적으로 차단하기 위해 설계된 저수준 프리미티브(low-level primitive) 모듈입니다. 상위 모듈인 `constant_time.rs`에서 요구하는 연산들을 대상 아키텍처에 최적화된 인라인 어셈블리(inline assembly) 명령어로 직접 구현하여, 타이밍 공격(timing attack) 및 부채널 공격(side-channel attack)에 대한 물리적 수준의 방어력을 제공합니다.

## 아키텍처 지원 및 구현 티어

이 모듈은 대상 시스템의 명령어 집합 아키텍처(instruction set architecture)와 데이터 타입의 크기에 따라 세 가지 티어로 나뉘어 동작합니다.

* **티어 1 (full asm):** `x86_64` 및 `aarch64` 환경의 `u32`, `u64` 타입에 적용됩니다. 연산의 전 과정을 순수 인라인 어셈블리로 처리하여, 상위 언어의 개입 없이 최고 수준의 보안성과 성능을 보장합니다.
* **티어 2 (barrier):** `x86_64` 및 `aarch64` 환경의 `u8`, `u16`, `u128` 타입에 적용됩니다. 어셈블리를 통한 최적화 배리어(optimization barrier) 설정으로 값을 보호한 후, 안전성이 검증된 Rust 비트 로직을 수행합니다.
* **티어 3 (fallback):** 그 외의 지원되지 않는 아키텍처에 적용됩니다. 표준 라이브러리의 컴파일러 힌트인 `black_box` 함수를 활용하여 최적화를 억제하고 순수 비트 연산으로 폴백(fallback)합니다.

## 주요 설계 및 보안 고려사항

### 어셈블리 수준의 통제

현대의 진보된 컴파일러는 중간 표현 단계에서 복잡한 비트 연산을 분석하여 더 빠른 실행 속도를 위해 **조건부 점프 명령어**로 역최적화(reverse-optimization)할 가능성이 있습니다. 이 모듈은 분기가 없는 어셈블리 명령어 시퀀스를 하드코딩하여 컴파일러의 분기 예측(branch prediction) 최적화 개입을 근본적으로 차단합니다.

### 플래그 및 레지스터 보존

인라인 어셈블리를 실행할 때 `preserves_flags` 옵션을 적절히 부여하고, 상태 플래그가 영향을 받는 산술 명령어들을 세밀하게 통제하여 메모리 및 스택 참조를 배제(`nomem`, `nostack`)함으로써 부수 효과를 최소화합니다.

## API 상세 명세

### `CtPrimitive` 트레이트

조건 분기를 배제하고 상수 시간 내에 마스크를 생성하거나 값을 선택하는 저수준 연산을 정의합니다. 반환되는 마스크는 모든 비트가 1인 상태(참) 혹은 모든 비트가 0인 상태(거짓)로 구성됩니다.

* `fn ct_fence(self) -> Self`
  값에 대한 컴파일러의 추론 및 레지스터 최적화를 강제로 차단하는 펜스(fence) 역할을 수행합니다. 빈 어셈블리 블록을 통과시켜 컴파일러가 해당 변수의 상태를 알 수 없도록 만듭니다.
* `fn ct_nonzero(self) -> Self`
  값이 0이 아닐 경우 참 마스크를, 0일 경우 거짓 마스크를 반환합니다. `x86_64`에서는 캐리 플래그(carry flag)를 발생시키는 `neg`와 이를 차감하는 `sbb` 명령어를, `aarch64`에서는 상태 레지스터를 갱신하는 `subs`와 `sbc` 명령어를 활용하여 분기 없이 마스크를 생성합니다.
* `fn ct_zero(self) -> Self`
  `ct_nonzero`의 결과에 비트 반전(not) 명령어를 추가하여 0일 때 참 마스크를 반환하도록 구현합니다.
* `fn ct_negative(self) -> Self`
  값의 최상위 비트(msb)를 추출하여 전체 비트로 확장합니다. 산술적 우측 시프트 동작과의 혼동을 피하기 위해 논리적 우측 시프트(lsr 또는 shr) 명령어를 사용한 후, 단항 음수화(neg)를 통해 마스크를 완성합니다.
* `fn ct_equal(self, other: Self) -> Self`
  두 값을 배타적 논리합(xor)한 뒤, 두 값의 차이가 0인지 검사하는 어셈블리 시퀀스를 전개하여 동일 여부에 대한 마스크를 반환합니다.
* `fn ct_not_equal(self, other: Self) -> Self`
  `ct_equal` 명령어 시퀀스에서 마지막 반전(not 또는 mvn) 연산을 생략하여 서로 다를 때 참이 되는 마스크를 생성합니다.
* `fn ct_mux(self, other: Self, mask: Self) -> Self`
  주어진 마스크 값에 따라 두 입력값 중 하나를 선택하는 다중화기(multiplexer) 역할을 합니다. 두 값에 대한 배타적 논리합 연산 후 마스크를 통한 논리곱(and)을 수행하고, 다시 배타적 논리합을 취하여 상태 분기 없이 단일 값을 계산해냅니다.

## 구현 세부 사항

* **타입 위임(type delegation):** 매크로(`impl_ct_delegate!`)를 활용하여 `i8`부터 `i128`까지의 부호 있는(signed) 타입과 `usize`, `isize` 등 포인터 폭(pointer width)에 의존적인 타입들을 동일한 비트 폭을 갖는 부호 없는(unsigned) 기본 타입으로 캐스팅하여 로직을 재사용합니다.
* **하위 워드 처리 한계:** `aarch64` 등의 아키텍처에서는 8비트 및 16비트 레지스터에 대한 직접적인 논리 연산 제어가 까다로우므로, `u8` 및 `u16` 타입은 `u32` 레지스터 규격으로 승격시켜 배리어를 통과한 후 Rust 상의 비트 연산으로 마무리하도록 설계되었습니다.