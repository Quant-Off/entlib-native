# 얽힘 라이브러리 네이티브

[얽힘 라이브러리](https://github.com/Quant-Off/entanglementlib)의 핵심 로직은 모두 이 [Rust 기반 네이티브 라이브러리](https://github.com/Quant-Off/entlib-native)에서 진행됩니다. 이 문서에선 편하게 "네이티브"라고 부르겠습니다.

이 문서에서, 이 네이티브가 얽힘 라이브러리와 어떻게 동작하는지와, 보안 작업을 어떻게 수행하는지 기술적으로 정확히 짚어드리고 싶지만 이 내용은 매-우 방대하기 떄문에 따로 [우리 문서 사이트](https://docs.qu4nt.space/docs/projects/entanglementlib/entlib-native)에 세밀히 정리해두겠습니다.

# 설계 철학

네이티브의 설계 철학은 한 문장으로 요약됩니다: **보안 연산에 관여하는 모든 코드는 외부 의존 없이, 스스로 통제할 수 있어야 한다.**

이 원칙은 단순히 외부 크레이트를 배제하겠다는 강박이 아닙니다. 보안 연산의 생명주기 전체를 직접 설계하고, 각 바이트가 언제 생성되고 언제 소거되는지를 개발자가 명시적으로 보장할 수 있어야 한다는 의미입니다. 외부 라이브러리가 내부적으로 어떤 최적화를 수행하는지, 어떤 임시 버퍼를 남기는지는 제가 통제할 수 없습니다. 따라서 네이티브에서 수행하는 모든 보안 연산은 직접 구현합니다.

이 철학 위에서, 네이티브는 다음 네 가지 원칙을 지킵니다.

**1. 메모리 소거의 보장.** 민감한 데이터를 다루는 모든 구조체는 범위를 벗어나는 순간 내부 상태가 완전히 소거됩니다. Rust의 `Drop` 트레이트와 `write_volatile`을 결합하여 컴파일러의 죽은 코드 제거(DCE) 최적화가 소거 로직을 건너뛰지 못하도록 강제하고, `compiler_fence`로 소거 순서를 보장합니다.

**2. 상수 시간 연산.** 비밀 데이터에 의존하는 비교, 선택, 분기 등 모든 연산은 입력 값에 관계없이 동일한 시간 내에 완료됩니다. 조건 분기 대신 비트마스크 기반 선택을 사용하며, `x86_64`와 `aarch64` 아키텍처에서는 인라인 어셈블리를 통해 컴파일러의 개입 없이 명령어 수준에서 이를 보장합니다.

**3. 하드웨어 수준의 제어.** 난수 생성은 CPU의 하드웨어 엔트로피 소스(`rdseed`, `rdrand`, `rndr`)를 직접 호출하며, 상수 시간 연산 역시 아키텍처별 어셈블리 명령어를 직접 작성합니다. 소프트웨어 계층의 추상화가 아닌, 하드웨어가 제공하는 보장에 기반합니다.

**4. 감사 가능한 코드.** 보안 연산에 관여하는 코드는 외부 크레이트 없이 이 저장소 안에서 완결됩니다. 보안 검토 시 추적해야 할 코드의 범위가 명확하며, 의존성 체인에 의한 공급망 공격 표면을 원천적으로 차단합니다.

# 상호 작용

네이티브는 얽힘 라이브러리 측에서 [FFM API(Linker API)](https://openjdk.org/jeps/454)를 통해 안전하며 빠르게 호출됩니다.

얽힘 라이브러리에서 민감 데이터를 처리할 때, [민감 데이터 컨테이너](https://docs.qu4nt.space/docs/projects/entanglementlib/sensitive-data-container) 로직은 `MemorySegment`를 통해 네이티브에 메모리 주소를 전송하고, 네이티브는 메모리 주소를 받아 보안 연산 후 완벽하게 소거하여 Raw 결과를 얽힘 라이브러리에 전송합니다. 즉, 전체적으로 Heap 메모리에 데이터를 보관할 필요가 전혀 없기 때문에 얽힘 라이브러리의 가비지 컬렉터(GC)가 바보같은 실수를 할 필요도 없어집니다.

# 모든 연산의 보안성

네이티브는 보안 철학에 따라 모든 보안 연산에 있어 기본적으로 외부 크레이트의 의존 없이 구현됩니다. 하지만 당연히 이것이 보안성과 직결되지 않습니다. 그렇다면 네이티브는 어떻게 연산을 안전하게 수행할까요?

## 휘발성 메모리 소거

보안 연산에서 가장 기본적이면서 가장 중요한 것은 "사용이 끝난 민감 데이터가 메모리에 남지 않는 것"입니다. 일반적인 제로화 코드(예를 들어 배열을 0으로 채우는 루프)는 컴파일러가 "이후 읽히지 않는 쓰기"로 판단하여 최적화 과정에서 제거할 수 있습니다. 이른바 죽은 코드 제거입니다.

네이티브에서는 `core::ptr::write_volatile`을 사용하여 모든 소거 연산이 컴파일러 최적화를 관통하도록 강제합니다. 이어서 `compiler_fence(Ordering::SeqCst)`로 메모리 배리어를 설정하여 소거가 의도된 순서대로 완료됨을 보장합니다. 이 패턴은 해시 내부 상태(`KeccakState`, `Sha256State` 등), 보안 버퍼(`SecureBuffer`), 난수 생성기 상태(`MixedRng`), 그리고 연산 중 사용되는 임시 변수까지 모두 일관되게 적용됩니다.

## 상수 시간 연산

타이밍 사이드 채널 공격은 연산 시간의 미세한 차이를 관측하여 비밀 데이터를 추론합니다. 네이티브의 `constant_time` 모듈은 비밀 데이터에 의존하는 모든 연산이 입력 값과 무관하게 동일한 명령어 경로를 실행하도록 설계되었습니다.

핵심 원칙은 조건 분기(`if-else`)를 사용하지 않고, 비트 연산만으로 결과를 선택하는 것입니다. 비교 결과는 `bool`이 아닌 비트마스크(`0` 또는 `!0`)로 반환되며, 이 마스크를 통해 분기 없이 값을 선택합니다. 아키텍처별로 세 단계(Tier)의 구현을 갖추고 있습니다:

- **Tier 1 (완전 어셈블리):** `x86_64`, `aarch64`에서 32비트 및 64비트 타입에 대해 순수 인라인 어셈블리로 구현합니다. Rust 컴파일러가 명령어를 재배치하거나 분기로 변환할 가능성을 원천 차단합니다.
- **Tier 2 (어셈블리 배리어):** 동일 아키텍처에서 8비트, 16비트, 128비트 타입에 대해 어셈블리 최적화 배리어와 Rust 비트 연산을 조합합니다.
- **Tier 3 (폴백):** 그 외 아키텍처에서 `core::hint::black_box`를 사용하여 최적화를 억제하고, 순수 Rust 비트 연산으로 구현합니다.

이 상수 시간 원시 연산은 `Base64` 인코딩/디코딩 등 실제 연산에 직접 사용됩니다.

## 하드웨어 엔트로피

소프트웨어 의사 난수 생성기(PRNG)만으로는 엔트로피 소스의 품질을 보장하기 어렵습니다. 네이티브의 난수 생성기는 CPU가 제공하는 하드웨어 엔트로피 소스를 직접 호출합니다. `x86_64` 환경에서는 [NIST SP 800-90B](https://csrc.nist.gov/pubs/sp/800/90/b/final) 준거 `rdseed` 명령어를 우선 사용하고, `aarch64` 환경에서는 ARMv8.5-A의 `RNDR` 레지스터를 읽습니다.

순수 하드웨어 출력에 추가적인 비선형 혼합이 필요한 경우, ChaCha20 코어 블록 기반의 `MixedRng`를 통해 하드웨어 엔트로피를 키와 논스로 사용한 스트림을 생성합니다. 이 과정에서 사용된 내부 상태와 스택 위의 중간값 역시 연산 완료 후 휘발성 소거됩니다.

## SecureBuffer

네이티브의 연산 결과는 일반적인 `Vec<u8>`이나 바이트 배열로 Java Heap에 직접 전달되지 않습니다. 대신 `SecureBuffer` 구조체에 담겨 Off-Heap 메모리에 유지되며, Java 측에는 오직 해당 메모리의 원시 포인터만 전달됩니다.

이 설계가 필요한 이유는 명확합니다. Java의 가비지 컬렉터는 Heap 객체를 자유롭게 복사하고 이동시키며, 원본 위치의 데이터가 언제 소거될지 보장하지 않습니다. `SecureBuffer`는 이 문제를 원천적으로 회피합니다. Java가 데이터 사용을 마치고 해제를 요청하면, `Drop` 트레이트에 의해 내부 바이트가 휘발성 소거된 후 메모리가 반환됩니다.

# 구성

네이티브는 가상 매니페스트(virtual manifest) 기반의 워크스페이스로 구성되며, 각 크레이트는 명확한 책임 경계를 가집니다.

## core/helper

`no_std` 환경에서 동작하는 보안 원시 연산 모듈입니다. 상수 시간 비교 및 선택 연산(`ConstantTimeOps` 트레이트), 아키텍처별 인라인 어셈블리 구현(`CtPrimitive` 트레이트), 상수 시간 `Base64` 인코딩/디코딩, 그리고 `SecureBuffer`를 제공합니다. 네이티브의 다른 모든 크레이트가 의존하는 기반 계층입니다.

## core/ffi

Java 측 FFM API와 직접 맞닿는 C ABI 브릿지 계층입니다. `Base64` 인/디코딩 FFI 엔드포인트(`entlib_b64_encode_secure`, `entlib_b64_decode_secure`)와 메모리 소거 엔드포인트(`entanglement_secure_wipe`), `SecureBuffer`의 포인터 추출 및 해제 함수를 제공합니다. 모든 진입점에서 널 포인터 검증과 오버플로 보호를 수행합니다.

## crypto/rng

하드웨어 기반 난수 생성 모듈입니다. CPU의 `rdseed`/`rndr` 명령어를 직접 호출하는 기본 생성기(`base_rng`)와, 하드웨어 엔트로피를 ChaCha20 코어 블록으로 비선형 혼합하는 확장 생성기(`MixedRng`)를 제공합니다.

## crypto/sha2

SHA-2 계열 해시 함수 구현입니다. `SHA-224`, `SHA-256`, `SHA-384`, `SHA-512` 네 가지 변형을 제공하며, 내부 상태 구조체(`Sha256State`, `Sha512State`)는 `Drop` 트레이트를 통해 연산 완료 시 자동 소거됩니다. 메시지 스케줄 등 연산 중간의 임시 데이터 역시 휘발성 소거 후 메모리 배리어가 적용됩니다.

## crypto/sha3

SHA-3 계열 해시 함수 및 XOF(확장 출력 함수) 구현입니다. `Keccak` 스펀지 구조 위에 `SHA3-224`, `SHA3-256`, `SHA3-384`, `SHA3-512` 고정 출력 변형과 `SHAKE128`, `SHAKE256` 가변 출력 변형을 제공합니다. 내부 상태(`KeccakState`)의 25개 64비트 레인과 200바이트 버퍼는 `Drop` 트레이트에 의해 자동 소거되며, Keccak-f[1600] 순열의 임시 상태 역시 매 호출마다 휘발성 소거됩니다.
